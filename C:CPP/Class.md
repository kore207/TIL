---

C++ 기본 재정리

---

#### 클래스와 구조체

* c++에서 클래스와 구조체의 유일한 차이는 구조체에 대한 디폴트 접근 제어는 public 이고 클래스에 대한 디폴트 접근 제어는 private 이다.

- 인라인 함수
- * 함수를 호출하지 않고 함수의 코드를 그자리에서 그대로 실행한다. 즉 , 컴파일러는 함수를 사용하는 부분에 함수의 코드를 복제해서 넣어준다. 
  * 클래스 선언 안에 정의를 가지고 있는 모든 함수는 자동으로 인라인 함수가 된다.
  * 외부에 함수를 정의하면 구현 부분에서 그 함수를 정의할 때 inline 제한자를 앞에 붙이면 된다.
- 같은 클래스의 객체에서의 데이터는 서로다른 메모리 영역을 차지하지만 같은 메서드를 호출하여 사용한다.

### 클라이언트-서버 모델

- OOP 프로그래머들은 프로그램 설계를 클라이언트-서버 모델로 자주 이야기한다.
  - 클라이언트 = 클래스를 사용하는 프로그램 -> public 으로 정의된 인터페이스를 통해서만 서버를 사용한다.
  - 서버(서버 설계자) = 그 서버가 인터페이스에 따라 신뢰성 있고 정확하게 수행되는지 확인하는 것

### 클래스 생성 소멸

- 클래스를 설계할 때, 모든 클래스 멤버들을 암시적으로 초기화하는 디폴트 생성자를 사용자가 제공해야 한다.
- 일반적으로 사용자가 코드에 명시적으로 파괴자를 호출하면 안된다.

### Const 멤버 함수

~~~c
const Stock land = Stock("Kludegon Properties");
land.show();
~~~

- show() 메서드는 매개변수를 갖지 않는다. 대신에 show() 메서드가 사용하는 객체는 메서드 호출에 의해 암시적으로 제공되고 있다. 그러므로 함수가 호출 객체를 변경하지 않는다고 약소하는 C++ 문법은 함수 괄호 뒤에 const 키워드를 넣는 것이다.
- void show() const;

### 클래스 사용 범위 상수

- 클래스 사용 범위를 가진 기호 상수를 사용하는 것이 좋을 때가 있다. 예를 들어 특정 클래스의 변수를 모두  동일하게 하기위해 모든 객체들이 공유하는 하나의 상수로 만들떄

  ~~~c
  class Stock
  {
  	privatd:
  		const int Months = 12; //Error
  		double consts[Months];
  }
  ~~~

  와 같은 오류를 범할 수 있다. 왜냐하면 클래스를 선언하는 것은 **객체가 어떻게 생겼는지 서술하는 것이지, 그 객체를 생성하는 것은 아니기 때문이다.**

  따라서 값을 저장할 기억 공간은 객체가 생성될 때까지 마련되지 않는다.(but C++11 이 멤버 초기화를 제공하지만 위의 과정은 아니다.)

- - 동일한 효과를 내는 두가지 방법

  - 1. 클래스 내부의 열거체 선언

    -> 클래스 선언 안에 주어지는 열거체는 클래스 사용 범위를 가진다.

    ~~~c 
    class Bakery
    {
    private:
    	enum {Months =12};//1
    	double consts[Months];
    	static const int Months =12; //ok
    }
    ~~~

    이러한 방식으로 열거체를 선언하는 것은, 클래스 데이터 멤버를 생성하지 않는다.

    즉, 개별적인 각 객체는 그안에 열거체를 담지 않는다.

  - 2. Static 사용 이것은 객체 안이 아니라 다른 정적 변수드로가 함께 저장되는 하나의 상수를 생성, 모든 객체들이 하나의 상수를 공유한다.

- 범위가 정해진 enum (c++11)

- * 기존의 enum 사용에서 충돌의 위험을 줄이기 위해 class 를 도입 하였다.

    